# Mysql是怎样运行的：第十八章笔记

---

## 缓存的重要性

---

InnoDB 存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据从磁盘全部加载到内存中（即使只访问一个页的一条记录，那也需要先把整个页的数据加载到内存中）。在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其**缓存**起来，这样将来有请求再次访问该页面时，就可以省去磁盘 IO 的开销了。

<br />

## InnoDB 的 Buffer Pool

---

为了缓存磁盘中的页，MySQL 服务器在启动时就会向操作系统申请一片**连续**的内存，这片内存便名为 **Buffer Pool（缓冲池）**，默认大小为 128M。可以在启动服务器的时候配置`innodb_buffer_pool_size`值，它表示 Buffer Pool 的大小。

```mysql
[server]
# Buffer Pool 大小单位为字节（Byte），最小值为 5M，设置小于最小值的大小会自动设置为 5M。
# 268435456 / 1024 / 1024 = 256M
innodb_buffer_pool_size = 268435456
```

<br />

### Buffer Pool 的内部组成

---

Buffer Pool 中默认的缓存页大小和磁盘上默认的页大小均为 16KB。每个缓存页都有一些所谓的**控制信息**。控制信息中包含了该页所属的表空间编号、页号、缓存页在 Buffer Pool 中的地址、链表节点信息、一些锁信息以及 LSN 信息等。

我们将每个页对应的控制信息占用的一块内存称为一个**控制块**，每个缓存页的控制块大小相同，控制块和缓存页是一一对应的，它们均被存放到了 Buffer Pool 中。

Buffer Pool 对应的内存空间解构如下（按序号从左到右在内存空间排列）：

1. 控制块部分：存放着与缓存页一一对应的控制块们。
2. 碎片：在分配足够多的控制块和缓存页后，可能剩余的空间不够一对控制块和缓存页的大小，那么这点空间就不会被用到，成为了碎片。
3. 缓存页部分：存放着与控制块一一对应的缓存页们。

**注意：控制块部分的第一个控制块对应缓存页部分的第一个缓存页，以此类推。**

每个控制块约占用缓存页大小的 5%，在 MySQL5.7.21 版本中，每个控制块占用的大小是 808 字节。设置的`innodb_buffer_pool_size`值并不包含控制块部分的大小，InnoDB 在为 Buffer Pool 向操作系统申请连续的内存空间时，这片连续的内存空间一般会比`innodb_buffer_pool_size`的值大 5% 左右。

<br />

### free 链表的管理

---

初启动 MySQL 服务器时，需要完成对 Buffer Pool 的初始化，初始化过程如下：

1. 向操作系统申请 Buffer Pool 的内存空间。
2. 将 Buffer Pool 的内存空间划分成若干对控制块和缓存页。

此时并没有真实的磁盘页被缓存到了 Buffer Pool 中，因为还没有用到真实的磁盘页。

那当我们需要用到真实的磁盘页时，它应该放到 Buffer Pool 中哪个缓存页的位置呢？或者说，我们如何区分 Buffer Pool 中哪些缓存页是空闲的？

MySQL 将所有空闲缓存页对应的一个个控制块作为一个个节点放到一个**双向链表**中，这个链表就是 **free 链表（又称空闲链表）**。假设 Buffer Pool 中可容纳的缓存页数量为 n，那么初始时，free 链表节点的数量就为 n。

free 链表有一个**基结点**，里面包含了 free 链表的头节点地址，尾节点地址，以及当前链表中节点的数量等信息。需要注意的是，这个基结点占用的内存空间并不包含在 `innodb_buffer_pool_size`值指定的 Buffer Pool 的大小中，而是在一块单独申请的内存空间中。

**注意：链表基结点占用的内存空间并不大，在 MySQL5.7.21 版本中，每个链表基结点只占用 40 Byte。后边介绍的许多不同链表，它们的基节点和 free 链表基节点的内存分配方式是一样的，都是单独申请的一块 40 Byte 大小的内存空间，并不包含在为 Buffer Pool 申请的一大片连续内存空间之内。**

free 链表的每个节点（控制块）中都包含着 free 链表的 pre 和 next 指针。

这样，我们就知道如何缓存真实的磁盘页了，步骤如下：

1. 从 free 链表中取一个空闲的缓存页，并把该缓存页对应的控制块信息填上（即该页所在的表空间、页号之类的信息）。
2. 把该缓存页对应的 free 链表节点从链表中移除，表示该缓存页已经被使用了。

<br />

### 缓存页的哈希处理

---

当我们需要从 Buffer Pool 中使用我们已经缓存的磁盘页时，我们应该如何快速定位到对应的缓存页？遍历？不行，最快的当然是哈希表。

我们将 表空间号+页号 作为 key，缓存页作为 value 创建一个哈希表，在访问某个页的数据时，先从哈希表中根据 表空间号 + 页号 看看有没有对应的缓存页，有则直接使用即可，无则从 free 链表中选一个空闲的缓存页，然后把磁盘中对应的页加载到该缓存页的位置。

<br />

### flush 链表的管理

---









































