# Mysql是怎样运行的：第二十章笔记

---

## redo 日志是什么

---

因为 InnoDB 存储引擎是以页为单位来管理存储空间的，所以所有的增删改查操作，本质上都是在访问页面。而由于 Buffer Pool 的存在，在真正访问页面之前我们会将页面缓存到 Buffer Pool 中，之后才进行真正的访问。

在 Buffer Pool 中修改了页面会在之后的某个时间点刷新页面的数据到磁盘，在刷新到磁盘之前，若是系统崩溃（这样事务所做的修改就丢失了），我们如何保证事务的持久性？

最简单的办法就是，**在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘**，但是这会引发两个问题：

* 即使我们只修改了页面中的一个字节（我们知道一个页面的默认大小是 16KB），我们都需要将**整个页面**刷新到磁盘，这样做太“浪费”了点。
* 一个事务可能包含多条语句，一条语句可能修改多个页面，修改的多个页面可能并不相邻。也就是说，在将 Buffer Pool 中某个事务修改的诸多页面刷新到磁盘时，需要进行很多的**随机 IO**。随机 IO 是比顺序 IO 慢的。

那如何解决这两个问题呢？换种思考方式，**我们只把修改了的那些东西记录下来**，不就行了？何必在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘呢？

例如，将第 0 号表空间的 100 号页面的偏移量为 1000 处的值更新为 2，这句话刷新到磁盘上。这样的话即使 Buffer Pool 中的页面没有被刷新到磁盘上系统就崩溃了，也能在系统重启后按照上面那句话中的步骤，重做一遍以更新对应的数据页，保证了事务的持久性。也因此我们可以引出如下概念，**记录了事务对数据库做了哪些修改的日志**，被称之为**重做日志（英文名：redo log）**，也被称为 **redo 日志**。

只将事务执行过程中产生的 redo 日志刷新到磁盘的好处如下：

* redo 日志占用的空间很小。存储表空间 ID、页号、偏移量以及需要更新的值，所需的存储空间是很小的。
* redo 日志是顺序写入磁盘的。执行事务的过程中，每执行一条语句，都有可能产生若干条 redo 日志，**这些日志是按照产生的顺序写入磁盘的**，**也就是使用了顺序 IO**。

<br />

## redo 日志格式

---

InnoDB 针对事务对数据库的不同修改场景，定义了多种类型的 redo 日志。在 MySQL 5.7.21 这个版本中，redo 日志共设计了 53 种不同的类型。

redo 日志的通用结构如下（各个部分按序号顺序，从左到右排列）：

1. type：该条 redo 日志的类型。
1. space ID：表空间 ID。
1. page number：页号。
1. data：该条 redo 日志的具体内容。

<br />

## 简单的 redo 日志类型

---

若某个表未被显式的定义主键，并且表中也没有定义 Unique 键，那么 InnoDB 会自动的为表添加一隐藏列作为主键，名为 row_id。为这个隐藏列赋值的方式如下：

* 服务器在内存中维护着一个全局变量（假设为全局变量 A），每当向某个包含隐藏列 row_id 的表中插入一条记录时，就会把该全局变量的值当作新记录的 row_id 列的值，并且把该全局变量自增 1。

* 当全局变量 A 的只是 256 的倍数时，就会将全局变量 A 的值刷新到系统表空间页号为 7 的页面的一个称之为 Max Row ID 的属性处。

* 系统启动时，会将 Max Row ID 属性的值加载到内存中，而后将该值加上 256 赋值给全局变量 A。

  我们知道全局变量 A 加上多少数字，是为了避免以后产生重复的 row_id 列值，但为什么偏偏是加上 256 呢？因为，上次系统关闭时，全局变量 A 的值可能大于 Max Row ID 属性值，但一定会小于 Max Row ID 属性值加 256（因为全局变量 A 的值是 256 的倍数时，会被刷新到 Max Row ID 属性处）。

Max Row ID 属性占用的存储空间是 8 个字节。也就是说当某个事务向某个包含 row_id 隐藏列的表插入一条记录时，若为记录分配的 row_id 列值为 256 的倍数，那么就会向系统表空间页号为 7 的页面的相应偏移量处写入 8 个字节的值。这一操作是在 Buffer Pool 中完成的，我们需要为这一操作记录一条 redo 日志。redo 日志记录的内容很简单，即记录了在某个页面的某个偏移量处修改了几个字节的值，具体被修改的内容是什么。InnoDB 将这种极其简单的 redo 日志称为**物理日志**。**根据在页面中写入数据的多少**，有以下几种不同的 redo 日志类型：

* MLOG_1BYTE（type 字段对应的十进制数字为 1）：表示在页面的某个偏移量处写入 1 个字节的 redo 日志类型。
* MLOG_2BYTE（type 字段对应的十进制数字为 2）：表示在页面的某个偏移量处写入 2 个字节的 redo 日志类型。
* MLOG_4BYTE（type 字段对应的十进制数字为 4）：表示在页面的某个偏移量处写入 4 个字节的 redo 日志类型。
* MLOG_8BYTE（type 字段对应的十进制数字为 8）：表示在页面的某个偏移量处写入 8 个字节的 redo 日志类型。
* MLOG_WRITE_STRING（type 字段对应的十进制数字为 30）：表示在页面的某个偏移量处写入一串数据。

因此，在修改 Max Row ID 属性时，会记录一条类型为 MLOG_8BYTE 的 redo 日志，类型为 MLOG_8BYTE 的 redo 日志结构如下（各个部分按序号顺序，从左到右排列）：

1. type：该条 redo 日志的类型。
2. space ID：表空间 ID。
3. page number：页号。
4. offset：页面中的偏移量。
5. 具体数据。

类型为 MLOG_1BYTE、MLOG_2BYTE、MLOG_4BYTE 的 redo 日志结构和类型为 MLOG_8BYTE 的 redo 日志结构类似。而类型为 MLOG_WRITE_STRING 的 redo 日志结构如下：

1. type：该条 redo 日志的类型。
2. space ID：表空间 ID。
3. page number：页号。
4. offset：页面中的偏移量。
5. len：具体数据占用的字节数。
6. 具体数据。

类型为 MLOG_WRITE_STRING 的 redo 日志，其 len 字段的值分别为 1、2、4、8 时，类型为 MLOG_WRITE_STRING 的 redo 日志可以分别代替  MLOG_1BYTE、MLOG_2BYTE、MLOG_4BYTE 和 MLOG_8BYTE 这些类型的 redo 日志。MLOG_1BYTE、MLOG_2BYTE、MLOG_4BYTE 和 MLOG_8BYTE 这些类型的 redo 日志的诞生只是为了节省空间罢了。

<br />

## 复杂一些的 redo 日志类型

---



















