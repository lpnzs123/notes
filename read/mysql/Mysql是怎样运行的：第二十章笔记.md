# Mysql是怎样运行的：第二十章笔记

---

## redo 日志是什么

---

因为 InnoDB 存储引擎是以页为单位来管理存储空间的，所以所有的增删改查操作，本质上都是在访问页面。而由于 Buffer Pool 的存在，在真正访问页面之前我们会将页面缓存到 Buffer Pool 中，之后才进行真正的访问。

在 Buffer Pool 中修改了页面会在之后的某个时间点刷新页面的数据到磁盘，在刷新到磁盘之前，若是系统崩溃（这样事务所做的修改就丢失了），我们如何保证事务的持久性？

最简单的办法就是，**在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘**，但是这会引发两个问题：

* 即使我们只修改了页面中的一个字节（我们知道一个页面的默认大小是 16KB），我们都需要将**整个页面**刷新到磁盘，这样做太“浪费”了点。
* 一个事务可能包含多条语句，一条语句可能修改多个页面，修改的多个页面可能并不相邻。也就是说，在将 Buffer Pool 中某个事务修改的诸多页面刷新到磁盘时，需要进行很多的**随机 IO**。随机 IO 是比顺序 IO 慢的。

那如何解决这两个问题呢？换种思考方式，**我们只把修改了的那些东西记录下来**，不就行了？何必在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘呢？

例如，将第 0 号表空间的 100 号页面的偏移量为 1000 处的值更新为 2，这句话刷新到磁盘上。这样的话即使 Buffer Pool 中的页面没有被刷新到磁盘上系统就崩溃了，也能在系统重启后按照上面那句话中的步骤，重做一遍以更新对应的数据页，保证了事务的持久性。也因此我们可以引出如下概念，**记录了事务对数据库做了哪些修改的日志**，被称之为**重做日志（英文名：redo log）**，也被称为 **redo 日志**。

只将事务执行过程中产生的 redo 日志刷新到磁盘的好处如下：

* redo 日志占用的空间很小。存储表空间 ID、页号、偏移量以及需要更新的值，所需的存储空间是很小的。
* redo 日志是顺序写入磁盘的。执行事务的过程中，每执行一条语句，都有可能产生若干条 redo 日志，**这些日志是按照产生的顺序写入磁盘的**，**也就是使用了顺序 IO**。

<br />

## redo 日志格式

---

InnoDB 针对事务对数据库的不同修改场景，定义了多种类型的 redo 日志。在 MySQL 5.7.21 这个版本中，redo 日志共设计了 53 种不同的类型。

redo 日志的通用结构如下（各个部分按序号顺序，从左到右排列）：

1. type：该条 redo 日志的类型。
1. space ID：表空间 ID。
1. page number：页号。
1. data：该条 redo 日志的具体内容。

<br />

## 简单的 redo 日志类型

---

若某个表未被显式的定义主键，并且表中也没有定义 Unique 键，那么 InnoDB 会自动的为表添加一隐藏列作为主键，列名为 row_id。为这个隐藏列赋值的方式如下：

* 服务器在内存中维护着一个全局变量（假设为全局变量 A），每当向某个包含隐藏列 row_id 的表中插入一条记录时，就会把该全局变量的值当作新记录的 row_id 列的值，并且把该全局变量自增 1。

* 当全局变量 A 的只是 256 的倍数时，就会将全局变量 A 的值刷新到系统表空间页号为 7 的页面的一个称之为 Max Row ID 的属性处。

* 系统启动时，会将 Max Row ID 属性的值加载到内存中，而后将该值加上 256 赋值给全局变量 A。

  我们知道全局变量 A 加上多少数字，是为了避免以后产生重复的 row_id 列值，但为什么偏偏是加上 256 呢？这是因为，上次系统关闭时，全局变量 A 的值虽然可能会大于 Max Row ID 属性的值，但一定会小于 Max Row ID 属性值加 256 （因为全局变量 A 的值是 256 的倍数时，会被刷新到 Max Row ID 属性处）。

Max Row ID 属性占用的存储空间是 8 个字节。也就是说当某个事务向某个包含 row_id 隐藏列的表插入一条记录时，若为记录分配的 row_id 列值为 256 的倍数，那么就会向系统表空间页号为 7 的页面的相应偏移量处写入 8 个字节的值。这一操作是在 Buffer Pool 中完成的，我们需要为这一操作记录一条 redo 日志。redo 日志记录的内容很简单，即记录了在某个页面的某个偏移量处修改了几个字节的值，具体被修改的内容是什么。InnoDB 将这种极其简单的 redo 日志称为**物理日志**。**根据在页面中写入数据的多少**，有以下几种不同的 redo 日志类型：

* MLOG_1BYTE（type 字段对应的十进制数字为 1）：表示在页面的某个偏移量处写入 1 个字节的 redo 日志类型。
* MLOG_2BYTE（type 字段对应的十进制数字为 2）：表示在页面的某个偏移量处写入 2 个字节的 redo 日志类型。
* MLOG_4BYTE（type 字段对应的十进制数字为 4）：表示在页面的某个偏移量处写入 4 个字节的 redo 日志类型。
* MLOG_8BYTE（type 字段对应的十进制数字为 8）：表示在页面的某个偏移量处写入 8 个字节的 redo 日志类型。
* MLOG_WRITE_STRING（type 字段对应的十进制数字为 30）：表示在页面的某个偏移量处写入一串数据。

因此，在修改 Max Row ID 属性时，会记录一条类型为 MLOG_8BYTE 的 redo 日志，类型为 MLOG_8BYTE 的 redo 日志结构如下（各个部分按序号顺序，从左到右排列）：

1. type：该条 redo 日志的类型。
2. space ID：表空间 ID。
3. page number：页号。
4. offset：页面中的偏移量。
5. 具体数据。

类型为 MLOG_1BYTE、MLOG_2BYTE、MLOG_4BYTE 的 redo 日志结构和类型为 MLOG_8BYTE 的 redo 日志结构类似。而类型为 MLOG_WRITE_STRING 的 redo 日志结构如下：

1. type：该条 redo 日志的类型。
2. space ID：表空间 ID。
3. page number：页号。
4. offset：页面中的偏移量。
5. len：具体数据占用的字节数。
6. 具体数据。

类型为 MLOG_WRITE_STRING 的 redo 日志，其 len 字段的值分别为 1、2、4、8 时，类型为 MLOG_WRITE_STRING 的 redo 日志可以分别代替  MLOG_1BYTE、MLOG_2BYTE、MLOG_4BYTE 和 MLOG_8BYTE 这些类型的 redo 日志。MLOG_1BYTE、MLOG_2BYTE、MLOG_4BYTE 和 MLOG_8BYTE 这些类型的 redo 日志的诞生只是为了节省空间罢了。

<br />

## 复杂一些的 redo 日志类型

---

执行一条语句有时会修改诸多页面，包括系统数据页面和用户数据页面（用户数据指的是聚簇索引和二级索引对应的 B+ 树）。例如，一条 INSERT 语句，它除了要向 B+ 树的页面中插入数据，还可能更新系统数据 Max Row ID 的值。不过，我们更关心的是语句对 B+ 树所做的更新。

* 表中包含多少个索引，一条 INSERT 语句就可能更新多少棵 B+ 树。
* 针对某一棵 B+ 树，即可能更新叶子节点页面，也可能更新内节点页面，也可能创建新的页面（记录插入的叶子节点的剩余空间较少，不足以存放该记录，就会进行页面的分裂，在内节点页面中添加目录项记录）。

INSERT 语句对所有页面的修改都应该保存到 redo 日志中去。如何保存呢？我们从简单的开始思考。

对于一条插入的记录而言，假设叶子节点的剩余空间足够存放该记录，那么只更新该叶子节点的页面就好了，只需要记录一条 MLOG_WRITE_STRING 类型的 redo 日志即可，表明在页面的某个偏移量处增加了哪些数据。

但是真的这么简单吗？别忘了一个数据页中除了存储实际的记录之外，还有 File Header、Page Header、Page Directory 等部分。也就是说，每往叶子节点代表的数据页里插入一条记录，不止是更新该叶子节点的页面，还有其他的很多地方会跟着更新：

* 更新 Page Directory 中的槽信息。
* 更新 Page Header 中的各种页面的统计信息。例如 PAGE_N_DIR_SLOTS 表示的槽数量可能会更改，PAGE_HEAP_TOP 代表的还未使用的空间最小地址可能会更改，PAGE_N_HEAP 代表的本页面中的记录数量可能会更改。
* 数据页里的记录是按照索引列从小到大的顺序组成一个单向链表的，每插入一条记录，需要更新上一条记录的记录头信息中的 next_record 属性来维护这个单向链表。
* 等等...

综上所述，把一条记录插入到一个页面时需要更改的地方非常多。针对这么多的改动，若我们采取简单的物理 redo 日志来记录这些修改，有两种解决方案：

* 方案一：在每个修改的地方都记录一条 redo 日志。
* 方案二：将页面中第一个被修改的字节到最后一个被修改的字节之间的所有数据，都当成是一条物理 redo 日志中的具体数据。

两个方案的缺点也十分明显，前者当页面修改地方特别多时，记录的 redo 日志占用的空间可能比整个页面的占用空间都多。后者将没有修改的数据也加入到了 redo 日志中，太浪费了。

为了克服上述方案的缺点，InnoDB 提出了一些新的 redo 日志类型：

* MLOG_REC_INSERT（type 字段对应的十进制数字为 9）：表示插入一条使用**非紧凑行格式的记录**时的 redo 日志类型。
* MLOG_COMP_REC_INSERT（type 字段对应的十进制数字为 38）：表示插入一条使用**紧凑行格式的记录**时的 redo 日志类型。
* MLOG_COMP_PAGE_CREATE（type 字段对应的十进制数字为 58）：表示创建一个存储**紧凑行格式记录页面**的 redo 日志类型。
* MLOG_COMP_REC_DELETE（type 字段对应的十进制数字为 42）：表示删除一条使用**紧凑行格式记录**的 redo 日志类型。
* MLOG_COMP_LIST_START_DELETE（type 字段对应的十进制数字为 44）：表示从某条给定的记录开始，删除页面中一系列使用**紧凑行格式记录**的 redo 日志类型。
* MLOG_COMP_LIST_END_DELETE（type 字段对应的十进制数字为 43）：与 MLOG_COMP_LIST_START_DELETE 类型的 redo 日志呼应，表示删除一系列记录直到 MLOG_COMP_LIST_END_DELETE 类型的 redo 日志对应的记录为止。
* MLOG_ZIP_PAGE_COMPRESS（type 字段对应的十进制数字为 51）：表示**压缩一个数据页**的 redo 日志类型。
* 等等...

看完了上面，我们有两个疑问，分别来解答一下：

1. 问：哪些行格式是非紧凑的，哪些是紧凑的？什么是紧凑？

   答：Redundant 行格式是非紧凑的，Compact、Dynamic 和 Compressed 行格式是紧凑的。所谓紧凑，就是对应的行格式占用更小的存储空间。

2. 问：MLOG_COMP_LIST_START_DELETE 和 MLOG_COMP_LIST_END_DELETE 类型的 redo 日志存在的意义是什么？

   答：数据页中的记录是按照索引列大小顺序组成单向链表的，若我们要删除索引列值在某个范围区间的所有记录，这时我们采取删一条记录就写一条 redo 日志的方案未免效率太低，所以提出了 MLOG_COMP_LIST_START_DELETE 和 MLOG_COMP_LIST_END_DELETE 类型的 redo 日志，目的是减少 redo 日志的条数。

上述提出的新的 redo 日志，包含了两个层面的意思，一是**物理层面**，二是**逻辑层面**。

* 物理层面：指明了对哪个表空间的哪个页进行了修改。
* 逻辑层面：直接根据这些日志去将页面内某个偏移量处恢复成某个数据是不行的，而是需要调用一些事先准备好的**函数**，执行完这些函数后，才可以将页面恢复成系统崩溃前的样子。

以 MLOG_COMP_REC_INSERT 类型的 redo 日志为例，我们先看看它的结构（各个部分按序号顺序，从左到右排列）：

1. type：该条 redo 日志的类型。
2. space ID：表空间 ID。
3. page number：页号。
4. n_fields：该条记录有多少个字段。
5. n_uniques：决定该记录唯一的字段数量。
6. field1_len ~ fieldn_len：各个字段占用的存储空间的大小。
7. offset：前一条记录的地址。
8. end_seg_len：利用该字段可以计算出当前记录占用存储空间的总大小。
9. info bits：表示记录头信息前 4 个比特位的值以及 record_type 的值。
10. extra_size：记录的额外信息占用的存储空间大小。
11. mismatch index：为了节省 redo 日志大小而设立的字段。
12. 记录的真实数据。

我们详解一下上述结构的部分字段：

* n_uniques：**表示在一条记录中，需要几个字段的值才能确保记录的唯一性**，这样插入一条记录的时候，就可以按照记录的前 n_uniques 个字段进行排序。

  对于聚簇索引而言，n_uniques 的值为主键的列数，主键包含几列，n_uniques 就是多少。

  **注意：列数不是列含有的记录数。**

  对普通二级索引而言，n_uniques 的值为**索引列数+主键列数**。

  对唯一二级索引而言，n_uniques 的值是否为**索引列数**呢？

  不是的，对于唯一二级索引而言，n_uniques 的值仍为**索引列数+主键列数**。这是因为唯一二级索引对应的列的值可能为 NULL，而**索引列数+主键列数**可以确保唯一二级索引对应的列的值存在多个 NULL 值时，能通过主键的不同保证每一条记录的唯一性。

* field1_len ~ fieldn_len：代表该记录的若干个字段占用的存储空间的大小。

  **注意，无论记录的若干个字段对应的类型是固定长度大小的（例如 INT）还是可变长度大小的（例如 VARCHAR(M) ），对应的字段占用的大小始终要写入到记录对应的 redo 日志中。**

* offset：代表该记录的**前一条记录**在页面中的地址。这个字段用在向数据页中插入一条记录时，修改前一条记录的 next_record 属性动作上（数据页存在自己维护的记录链表，每条记录的**记录头信息**中都包含一个称为 next_record 的属性）。

* end_seg_len：利用该字段可以**间接**的计算出一条记录占用的存储空间的总大小。至于为什么不直接存储对应记录占用的存储空间的总大小，这是因为要节省 redo 日志的存储空间。也就是说，这个字段也是为了节省 redo 日志大小而设立的。

  **注意：一条记录由额外信息和真实数据两部分组成，这两部分的总大小就是一条记录占用的存储空间的总大小。**

注意到 MLOG_COMP_REC_INSERT 类型的 redo 日志并没有记录 PAGE_N_DIR_SLOTS（槽数量）、PAGE_HEAP_TOP（还未使用的空间最小地址） 和 PAGE_N_HEAP（本页面中的记录数量） 的值修改信息，MLOG_COMP_REC_INSERT 类型的 redo 日志只是把在页面中插入一条记录必备的所有要素记了下来（以下简称**必备要素**），这是为什么？

还记得 MLOG_COMP_REC_INSERT 类型的 redo 日志逻辑层面的含义吗？在系统崩溃重启后，服务器会调用相关的，向某个页面插入一条记录的那个函数，而必备要素，就是这个函数的**参数**。在这个函数调用执行结束后，对应页面中的 PAGE_N_DIR_SLOTS（槽数量）、PAGE_HEAP_TOP（还未使用的空间最小地址） 和 PAGE_N_HEAP（本页面中的记录数量） 的值就会恢复到系统崩溃之前的样子，而这，就是所谓的**逻辑日志**。

<br />

## redo 日志格式小结

---

redo 日志的**作用**，就是把事务在执行过程中对数据库所做的所有修改都记录下来，若之后发生了系统崩溃，待到系统重启后可以把事务所做的任何修改都恢复出来。

InnoDB 对 redo 日志结构中的某些字段可能会进行**压缩**处理。例如，spacd ID 和 page number 字段一般采用 4 个字节进行存储，但经过压缩后，可能会使用更小的空间来进行存储。

<br />

## Mini-Transaction

---

### 以组的形式写入 redo 日志

---

在执行 SQL 语句的过程中产生的 redo 日志被 InnoDB 划分成了若干个不可分割的**组**。

以向某个索引对应的 B+ 树中插入一条记录的这个过程为例，我们需要先定位到这条记录应该被插入到哪个叶子节点代表的数据页中，然后再分情况讨论：

* 情况一：该数据页剩余空闲空间充足，可以插入新纪录。

  此时直接把记录插入到这个数据页中，然后记录一条类型为 MLOG_COMP_REC_INSERT 的 redo 日志即可，同时，我们把类似于这样的插入称为**乐观插入**。

* 情况二：该数据页剩余空闲空间不足，不可以插入新记录。

  此时插入的步骤如下：

  1. 进行**页分裂**的操作，即新建一个叶子节点。
  2. 把原本准备插入新纪录的叶子节点对应的数据页的一部分记录，复制到新建的叶子节点对应的数据页中。
  3. 把新纪录插入到新建的叶子节点对应的数据页中。
  4. 把新建的叶子节点插入到叶子节点链表中。
  5. 在原本准备插入新纪录的叶子节点的父节点（即内节点）对应的数据页中添加一条目录项记录，指向这个新的叶子节点对应的数据页。

  显然，这些步骤要对多个页面进行修改，理所当然的，也就会产生很多条 redo 日志，同时，我们把类似于这样的插入称为**悲观插入**。

  步骤 5 中，若原本准备插入新纪录的叶子节点的父节点对应的数据页剩余空闲空间也不足，即无法容纳新增的目录项记录，那么父节点对应的数据页也要做分裂操作。这就会导致修改更多的页面，产生更多的 redo 日志。同时，对于悲观插入而言，申请新的数据页还要改动一些系统页面（如修改段、区的统计信息、各种链表的统计信息），这样生成的 redo 日志数量就相当多了（大概有 20、30 条）。

  **注意：在 InnoDB 的一些功能中，乐观插入也可能产生多条 redo 日志。**

现在假设我们在悲观插入过程中，刚刚执行到其步骤 5 时系统便崩溃了。这就意味着，我们在悲观插入的过程中只记录了一部分 redo 日志，在系统重启时，仅用这一部分 redo 日志明显是无法将系统恢复到崩溃之前的状态的，就算恢复一部分，我们得到的 B+ 树也是不正确的。

不可接受！所以 InnoDB 在执行需要保证原子性的操作时，必须以**组**的形式来记录 redo 日志。在系统崩溃重启时，也是针对一个组中的 redo 日志，要么全恢复，要么全不恢复！

那么 InnoDB 是如何做到这一点的呢？我们分情况讨论一下：

* 情况一：对一些会生成多条 redo 日志的原子性操作而言（例如向某个索引对应的 B+ 树中进行一次悲观插入），InnoDB 会在组中的最后一条 redo 日志后加上一条特殊类型的 redo 日志，该类型名称为 MLOG_MULTI_REC_END（type 字段对应的十进制数字为 31）。

  这条特殊类型的 redo 日志结构十分简单，只有一个 type 字段。

  这样，在系统崩溃重启后，只有解析到类型为 MLOG_MULTI_REC_END 的 redo 日志，InnoDB 才认为解析到了一组完整的 redo 日志，才会进行恢复。否则，直接放弃前面解析到的 redo 日志。

* 情况二：对一些只会生成一条 redo 日志的原子性操作而言（例如更新 Max Row ID 的操作），因为 redo 日志结构的 type 字段只占用 1 字节，且 redo 日志的类型数量不超过 127 个，所以 type 字段的第一个比特位，被用来表示该 redo 日志是否是一条单一的日志，剩下的七个比特位用来表示该 redo 日志的类型。

  若 type 字段的第一个比特位为 1，表示原子性操作只产生了单一的一条 redo 日志，否则表示原子性操作产生了一系列的 redo 日志。

讲完了组的概念，我们来说说它的应用场景：

* 更新 Max Row ID 属性时产生的 redo 日志是**不可分割的（即一组）**。
* 向聚簇索引对应的 B+ 树的页面中插入一条记录时产生的 redo 日志是不可分割的。
* 向某个二级索引对应 B+ 树的页面中插入一条记录时产生的 redo 日志是不可分割的。
* 等等...

<br />



















