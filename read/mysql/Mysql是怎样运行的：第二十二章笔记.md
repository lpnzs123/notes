# Mysql是怎样运行的：第二十二章笔记

---

## 事务回滚的需求

---

存在一些情况，会使事务执行到一半就结束，例如：

* 事务执行过程中可能遇到的各种错误，比如服务器本身的错误、操作系统的错误或突然断电导致的错误。
* 程序员在事务执行过程中手动输入`ROLLBACK`语句结束当前事务的执行。

**为了保证事务的原子性**，我们需要对只执行了一半的事务进行**回滚（英文名：rollback）**操作。

回滚时需要一些信息帮助我们进行回滚，例如：

* **插入**一条记录时，至少要把这条记录的主键值记下来，之后回滚时只需要把这个主键值对应的记录删除即可。
* **删除**一条记录时，至少要把这条记录中的内容都记下来，之后回滚时再把由这些内容组成的记录插入到表中即可。
* **修改**一条记录时，至少要把修改这条记录前的旧值都记录下来，之后回滚时再把这条记录更新为旧值即可。

需要注意的是，**查询**一条记录时，我们无需记录其帮助回滚的信息，因为查询操作不会修改仍和用户记录。

数据库将上述为了回滚而记录的信息，称之为**撤销日志（英文名：undo log）**，也可称为 undo 日志。

**不同类型的操作，产生的 undo 日志格式不同。**

在详解 undo 日志之前，我们先看看**事务 id**是什么。

<br />

## 事务 id

---

### 给事务分配 id 的时机

---

我们知道，一个事务可以是一个**只读事务**，或者是一个**读写事务**。

通过`START TRANSACTION READ ONLY`语句，我们可以开启一个只读事务。只读事务中，不可以对**普通的表（即其他事务也能访问到的表）**进行增、删、改操作，但是可以对临时表进行增、删、改操作。

通过`START TRANSACTION READ WRITE`语句，我们可以开启一个读写事务，或者使用`BEGIN`、`START`、`TRANSACTION`语句开启的事务默认也算是读写事务。在读写事务中，我们可以对表进行增删改查操作。

若某个事务的执行过程中对某个表执行了增、删、改操作，那么 InnoDB 存储引擎就会给这个事务分配一个独一无二的**事务 id**，**分配的方式如下（该事务 id 的分配策略针对于 MySQL 5.7）**：

* 对于只读事务，只有在它**第一次对某个用户创建的临时表**，执行增、删、改操作时，才会为这个事务分配一个事务 id，否则不分配。

  在前面的笔记中，我们说过对某个查询语句执行 EXPLAIN，分析这个查询语句的查询计划时，有时会在查询计划的 Extra 列中看到 Using temporary 的提示。这表明了，对应的查询语句在执行时，会用到**内部临时表**。这个内部临时表和我们手动用`CREATE TEMPORARY TABLE`语句创建的**用户临时表**不一样。在事务回滚时，并不需要把执行 SELECT 语句过程中用到的内部临时表也回滚。在执行 SELECT 语句用到内部临时表时，也并不会为它分配事务 id。

* 对于读写事务，只有在它**第一次对某个表（包括用户创建的临时表）**，执行增、删、改操作时，才会为这个事务分配一个事务 id，否则不分配。

  有时我们开启的一个读写事务中全是查询语句，并没有执行增、删、改的语句。这时，这个事务并不会被分配一个事务 id。

综上所述，只有在事务对表中的记录做改动的时候，才会为这个事务分配一个唯一的事务 id。

<br />

### 事务 id 是怎么生成的

---

事务 id 本质上是一个**数字**，它的分配策略和隐藏列 row_id（隐藏列 row_id 即当用户没有为表创建主键和 UNIQUE 键时，InnoDB 自动创建的列）的分配策略大抵相同，具体策略如下：

* 服务器在**内存中**维护着一个全局变量（假设为全局变量 A），每当需要为某个事务分配一个事务 id 时，就会把该全局变量的值当作事务 id 分配给该事务，并且把该全局变量自增 1。

* 当全局变量 A 的值是 256 的倍数时，就会将全局变量 A 的值刷新到系统表空间页号为 5 的页面的一个称之为 Max Trx ID 的属性处，该属性占用 8 个字节的存储空间。

* 系统启动时，会将 Max Trx ID 属性的值加载到内存中，而后将该值加上 256 赋值给全局变量 A。

  我们知道全局变量 A 加上多少数字，是为了避免以后产生重复的事务 id，但为什么偏偏是加上 256 呢？这是因为，上次系统关闭时，全局变量 A 的值虽然可能会大于Max Trx ID 属性的值，但一定会小于 Max Row ID 属性值加 256 （因为全局变量 A 的值是 256 的倍数时，会被刷新到 Max Trx ID 属性处）。

这样我们就保证了整个系统中分配的事务 id 值，是一个递增的数字。先被分配 id 的事务，得到的是较小的事务 id 值。后被分配 id 的事务，得到的是较大的事务 id 值。

<br />

### trx_id 隐藏列

---

还记得 InnoDB 记录行格式吗？我们说过：

聚簇索引的记录除了会保存完整的用户数据以外，还会自动添加名为 trx_id、roll_pointer 的隐藏列。若用户没有在表中定义主键以及 UNIQUE 键，还会自动添加一个名为 row_id 的隐藏列。

因此，一条记录在页面中的真实结构如下（各个部分按序号顺序，从左到右排列）：

1. 记录的额外信息。
2. row_id（可能有可能没有这一部分）。
3. trx_id。
4. roll_pointer。
5. 用户列信息。

其中 trx_id 即某个对这个聚簇索引记录做改动（即 INSERT、DELETE、UPDATE 操作）的语句，其所在的事务对应的事务 id。

<br />

###  undo 日志的格式

---

为了实现事务的原子性，InnoDB 存储引擎在实际进行增、删、改一条记录时，都需要先把对应的 undo 日志记下来。一般每对一条记录做一次改动，就对应着一条 undo 日志，但在某些更新记录的操作中，也可能会对应着 2 条 undo 日志。

**一个事务**在执行过程中可能新增、删除、更新**若干条**记录，也就是说需要记录很多条对应的 undo 日志。这些 undo 日志会从 0 开始编号，按照生成的顺序分别被称为第 0 号 undo 日志、第 1 号 undo 日志、...... 、第 n 号 undo 日志。这个编号也被称之为 undo no。

这些个 undo 日志会被记录到类型为 FIL_PAGE_UNDO_LOG 的页面（对应的十六进制是 0x0002）中。这些页面可以从系统表空间中分配，也可以从一种专门存放 undo 日志的表空间 undo tablespace 中分配。

为了下文的发展，我们在此创建一个名为 undo_demo 的表：

```mysql
CREATE TABLE undo_demo (
    id INT NOT NULL,
    key1 VARCHAR(100),
    col VARCHAR(100),
    PRIMARY KEY (id),
    KEY idx_key1 (key1)
)Engine=InnoDB CHARSET=utf8;
```

我们介绍 InnoDB 数据字典的时候说过，每个表都会被分配一个唯一的 table id，我们可以通过系统数据库 information_schema 中的 innodb_sys_tables 表来查看某个表对应的 table id 是多少。

```mysql
-- 查询 undo_demo 表对应的 table id
SELECT * FROM information_schema.innodb_sys_tables WHERE name = 'xiaohaizi/undo_demo';

-- 略去非关心的查询结果，查询到 undo_demo 表对应的 table id 为 138，记住这个值
```

接下来，我们就可以看看，不同操作会产生什么样子的 undo 日志了。

<br />

#### INSERT 操作对应的 undo 日志

---

前面的笔记中，我们说过向表中插入一条记录时，会有乐观插入和悲观插入的区分。但是不管如何插入，最终导致的结果就是把待插入的记录被放到了一个数据页中。如果需要回滚这个插入操作，直接把对应插入的记录删除即可。

也就是说，在写 INSERT 操作对应的 undo 日志时，主要记录的是待插入记录的主键信息。InnoDB 设计了一个类型为 TRX_UNDO_INSERT_REC 的 undo 日志，它的**结构**如下（各个部分按序号顺序，从上到下排列）：

1. end of record：本条 undo 日志结束，下一条开始时在页面中的地址。
2. undo type：本条 undo 日志的类型，也就是 TRX_UNDO_INSERT_REC。
3. undo no：本条 undo 日志对应的编号。
4. table id：本条 undo 日志对应的记录所在表的 table id。
5. 主键各列信息（结构为 <len, value>）：主键的**每个列**占用的存储空间大小（即 len）和真实值（即 value）。
6. start of record：上一条 undo 日志结束，本条开始时在页面中的地址。

这里我们需要强调几点：

* undo no 在**一个事务**中是从 0 开始递增的，即该事务没提交，每生成一条 undo 日志，该条日志的 undo no 就加 1。
* **若记录中的主键只包含一个列**，则在类型为 TRX_UNDO_INSERT_REC 的 undo 日志中，只需要把该列占用的存储空间大小和真实值记录下来。**若记录中的主键包含多个列**，则每个列占用的存储空间大小和对应的真实值，都需要被记录下来。
* 为了最大限度的节省 undo 日志所占用的存储空间，和 redo 日志类似，InnoDB 会对 undo 日志中的某些属性进行**压缩**处理。

当我们向某个表中插入一条记录时，实际上需要向聚簇索引和所有的二级索引都插入一条记录。不过由于聚簇索引记录和二级索引记录是一一对应的，我们在向某个表中插入一条记录时，只需要考虑向聚簇索引插入记录的情况便可。在回滚擦混入操作时，也只需要知道这条记录的主键信息，根据主键信息做对应的删除操作，删除操作执行时就会顺带着把所有的二级索引中的相应记录删除掉。后文中所述的 DELETE 操作和 UPDATE 操作对应的 undo 日志，也都是针对聚簇索引记录而言的。

现在我们向 undo_demo 表中插入一条记录，看看产生的 undo 日志的内容是什么。

```mysql
-- 开启事务，假设该事务的 id 为 100
BEGIN;

-- 插入语句 1
INSERT INTO undo_demo(id, key1, col) VALUES (1, 'AWM', '狙击枪');
```

插入语句 1 会产生一条 TRX_UNDO_INSERT_REC 类型的 undo 日志，其**内容**如下（各个部分按序号顺序，从上到下排列）：

1. end of record：地址
2. undo type：TRX_UNDO_INSERT_REC
3. undo no：0
4. table id：138
5. 主键各列信息（结构为 <len, value>）： <4, 1>
6. start of record：地址

这里需要注意的是主键各列信息字段的值为 <4, 1>，1 我们知道，就是插入记录的主键值 1，但是 4 呢？

还记得 undo_demo 表的主键 id 列是什么类型吗？是的，INT类型，而 INT 类型占用的存储空间长度就是 4 个字节。

<br />

#### roll_pointer 隐藏列的含义

---

roll_pointer 隐藏列占用 7 个字节，**是一个指向记录对应的 undo 日志的一个指针**。

插入语句 1 中向 undo_demo 表插入的一条记录对应着的一条 undo 日志，其记录会被存储到类型为 FIL_PAGE_INDEX 的页面（即数据页）中，其 undo 日志会被存储到类型为 FIL_PAGE_UNDO_LOG 的页面中。

```mysql
-- 插入语句 1
INSERT INTO undo_demo(id, key1, col) VALUES (1, 'AWM', '狙击枪');
```

<br />

#### DELETE 操作对应的 undo 日志

---

插入到页面中的记录会根据记录头信息中的 next_record 属性组成一个单向链表，这个单向链表被称为**正常记录链表**。

在介绍数据页结构时，我们说过被删除的记录也会根据记录头信息中的 next_record 属性组成一个链表，这个链表中记录占用的存储空间可以被重新利用，因此这个链表被称为**垃圾链表**。

在 Page Header 部分中，有一个被称为 PAGE_FREE 的属性，它指向由被删除记录组成的垃圾链表的头节点。

现在假设某个页面中记录的分布情况如下：

* 正常记录链表（每个序号代表一个节点，按序号从小到大的顺序，从上至下连接节点）：
  1. 正常记录，其记录头信息中 delete_mask 属性的值为 0。
  2. 正常记录，其记录头信息中 delete_mask 属性的值为 0。
  3. 正常记录，其记录头信息中 delete_mask 属性的值为 0。
* 垃圾链表（每个序号代表一个节点，按序号从小到大的顺序，从上至下连接节点）：
  1. PAGE_FREE 指向垃圾链表的头节点
  2. 已删除记录，其记录头信息中 delete_mask 属性的值为 1。
  3. 已删除记录，其记录头信息中 delete_mask 属性的值为 1。

**注意：delete_mask 属性标记了该记录是否被删除，值为 0 时代表记录没有被删除，值为 1 时代表记录被删除。**

现在假设我们使用 DELETE 语句把正常记录链表中最后一条记录给删除掉了，这个删除的过程需要经历两个阶段如下：

* 阶段一：将被删除的记录的 delete_mask 标识位置为 1，其他不做修改（其实会修改记录的 trx_id、roll_pointer 这些隐藏列的值）。**InnoDB 将阶段一亦称为 delete mask**。

  此时正常记录链表中最后一条记录的 delete_mask 值虽然为 1，但该记录并未加入到垃圾链表中，还在正常记录链表中。此时，该记录处于一个**中间状态**，成为了一个**中间状态记录**，**在删除语句所在的事务提交之前，被删除的记录会一直处于中间状态**。

  这种中间状态，是为了实现 MVCC 功能而存在的。

* 阶段二：**当删除语句所在的事务提交后**，会有专门的线程真正的把记录给删除掉。所谓真正的删除，即将记录从正常记录链表中移除，并加入到垃圾链表中，然后调整一些页面的其他信息，如：

  * 页面中的用户记录数量 PAGE_N_RECS。
  * 上次插入记录的位置 PAGE_LAST_INSERT。
  * 垃圾链表头节点的指针 PAGE_FREE。
  * 页面中可重用的字节数量 PAGE_GARBAGE。
  * 页目录的一些信息。
  * 等等...

  **InnoDB 将阶段一亦称为 purge**。

  阶段二执行完毕后，正常记录链表中的最后一条记录，已经从正常记录链表中移除并加入到了垃圾链表中。需要注意的是，这条记录是加入到了垃圾链表的**头节点**处，同时，PAGE_FREE 指针会指向这条新加入垃圾链表的记录（也就是会修改 PAGE_FREE 属性的值）。

  还记得页面 Page Header 部分中的 PAGE_GARBAGE 属性吗？该属性记录着当前页面中可重用的存储空间占用的总字节数。每当有已删除记录被加入到垃圾链表时，都会把这个 PAGE_GARBAGE 属性的值加上该已删除记录占用的存储空间大小。

  PAGE_FREE 指向垃圾链表的头节点。每当新插入记录时，会首先判断 PAGE_FREE 指向的头节点代表的已删除记录占用的存储空间，是否足够容纳这条新插入的记录。如果不可以，就直接向页面申请新的空间来存储这条记录，并不会尝试遍历整个垃圾链表，以找到一个可以容纳新记录的节点。如果可以，直接重用 PAGE_FREE 指向的头节点代表的已删除记录占用的存储空间，并把 PAGE_FREE 指向垃圾链表中下一条已被删除的记录。

  但是，若新插入的那条记录占用的存储空间大小**小于**垃圾链表头节点占用的存储空间大小，那就意味着头节点对应记录占用的存储空间，有一部分空间是用不到的（这部分空间被称之为**碎片空间**），那是否意味着，这部分空间永远都用不到了呢？

  不是的，这些碎片空间所占用的存储空间大小，会被统计到 PAGE_GARBAGE 属性中。这些个碎片空间在整个页面快被使用完之前，是不会被重新利用的。只有当页面快满，再插入一条记录，页面并不能分配一条完整记录的空间，并且 PAGE_GARBAGE 的空间和剩余可利用的空间加起来可以容纳下新插入的记录时，InnoDB 才会尝试**重新组织页面内的记录**。

  所谓重新组织，就是先开辟一个**临时页面**，把原页面内的记录**依次**插入到临时页面中（因为是依次插入的，所以临时页面中并不会产生碎片空间），之后再将临时页面的内容复制到原页面中，这样，我们就可以把那些原页面中的碎片空间给释放了。

  明显的，重新组织页面内的记录相当耗费性能。

（从上面的描述中我们也可以看出来，未完待续...）
