# Mysql是怎样运行的：第二十二章笔记

---

## 事务回滚的需求

---

存在一些情况，会使事务执行到一半就结束，例如：

* 事务执行过程中可能遇到的各种错误，比如服务器本身的错误、操作系统的错误或突然断电导致的错误。
* 程序员在事务执行过程中手动输入`ROLLBACK`语句结束当前事务的执行。

**为了保证事务的原子性**，我们需要对只执行了一半的事务进行**回滚（英文名：rollback）**操作。

回滚时需要一些信息帮助我们进行回滚，例如：

* **插入**一条记录时，至少要把这条记录的主键值记下来，之后回滚时只需要把这个主键值对应的记录删除即可。
* **删除**一条记录时，至少要把这条记录中的内容都记下来，之后回滚时再把由这些内容组成的记录插入到表中即可。
* **修改**一条记录时，至少要把修改这条记录前的旧值都记录下来，之后回滚时再把这条记录更新为旧值即可。

需要注意的是，**查询**一条记录时，我们无需记录其帮助回滚的信息，因为查询操作不会修改仍和用户记录。

数据库将上述为了回滚而记录的信息，称之为**撤销日志（英文名：undo log）**，也可称为 undo 日志。

**不同类型的操作，产生的 undo 日志格式不同。**

在详解 undo 日志之前，我们先看看**事务 id**是什么。

<br />

## 事务 id

---

### 给事务分配 id 的时机

---

我们知道，一个事务可以是一个**只读事务**，或者是一个**读写事务**。

通过`START TRANSACTION READ ONLY`语句，我们可以开启一个只读事务。只读事务中，不可以对**普通的表（即其他事务也能访问到的表）**进行增、删、改操作，但是可以对临时表进行增、删、改操作。

通过`START TRANSACTION READ WRITE`语句，我们可以开启一个读写事务，或者使用`BEGIN`、`START`、`TRANSACTION`语句开启的事务默认也算是读写事务。在读写事务中，我们可以对表进行增删改查操作。

若某个事务的执行过程中对某个表执行了增、删、改操作，那么 InnoDB 存储引擎就会给这个事务分配一个独一无二的**事务 id**，**分配的方式如下（该事务 id 的分配策略针对于 MySQL 5.7）**：

* 对于只读事务，只有在它**第一次对某个用户创建的临时表**，执行增、删、改操作时，才会为这个事务分配一个事务 id，否则不分配。

  在前面的笔记中，我们说过对某个查询语句执行 EXPLAIN，分析这个查询语句的查询计划时，有时会在查询计划的 Extra 列中看到 Using temporary 的提示。这表明了，对应的查询语句在执行时，会用到**内部临时表**。这个内部临时表和我们手动用`CREATE TEMPORARY TABLE`语句创建的**用户临时表**不一样。在事务回滚时，并不需要把执行 SELECT 语句过程中用到的内部临时表也回滚。在执行 SELECT 语句用到内部临时表时，也并不会为它分配事务 id。

* 对于读写事务，只有在它**第一次对某个表（包括用户创建的临时表）**，执行增、删、改操作时，才会为这个事务分配一个事务 id，否则不分配。

  有时我们开启的一个读写事务中全是查询语句，并没有执行增、删、改的语句。这时，这个事务并不会被分配一个事务 id。

综上所述，只有在事务对表中的记录做改动的时候，才会为这个事务分配一个唯一的事务 id。

<br />

### 事务 id 是怎么生成的

---



