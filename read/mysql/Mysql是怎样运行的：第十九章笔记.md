# Mysql是怎样运行的：第十九章笔记

---

## ACID

---

对数据库的每一个操作都相当于对操作对应的，现实世界中的对象的一次**状态转换**（例如数据库的一次转账操作使得现实世界中的账户的一次状态转换）。我们想让对数据库的操作符合现实世界中状态转换的规则，就必须先知道状态转换的规则有哪些。标题已经给出了答案，ACID，下面我们来介绍一下**数据库的四大特性（ACID）**。

<br />

### 原子性（Atomicity）

---

原子意味着不可分割。

一个操作可以被分解成若干个步骤，在执行这个操作后，有三种情况：

* 步骤全成功。
* 步骤中有些成功有些失败。
* 步骤全失败。

现在假设这个操作是一次转账，明显的，这个操作有两个基本的步骤（账户 A 转钱给账户 B）：

1. 把钱从账户 A 中取出来。
2. 把从账户 A 中取出来的钱转给账户 B。

问题来了，当步骤 1 完成后系统宕机，导致了步骤 2 没有进行，这时候怎么办呢？

这种情况应该是不允许发生的，我们希望两个步骤先后发生，要么全做，要么全不做，这才是一次转账操作，或者说，这就是**原子性**。也就是说，我们希望转账操作是原子的，是不可分割的，我们不希望转账操作还可以被分成两个步骤分别进行，存在可能一个成功一个失败的**中间态**。

如何处理一个不可分割的操作执行后产生的中间态？当然是将已经执行的操作撤销，将状态恢复到执行不可分割的操作之前的样子。

<br />

### 隔离性（Isolation）

---

仍以一次转账操作为例（账户 A 转钱给账户 B），列出操作的基本步骤如下（步骤做了二次细分，列出了更详细的步骤）：

1. 把钱从账户 A 中取出来。
   1. 从磁盘中读取账户 A 的金额。
   2. 账户 A 的金额减去转账的金额，为账户 A 的余额。
   3. 存储账户 A 的余额进磁盘里。
2. 把从账户 A 中取出来的钱转给账户 B。
   1. 从磁盘中读取账户 B 的金额。
   2. 账户 B 的金额加上转账的金额，为账户 B 的余额。
   3. 存储账户 B 的余额进磁盘里。

这里我们认为转账操作是原子的，不可分割。也就是说，上述步骤要么全做，要么全不做。现在我们**同时**执行两次转账金额相同的转账操作，两次都是账户 A 转钱给账户 B。

假设两次转账操作分别为 T1 和 T2，**理想情况下**，有两种执行方式：

* 先执行 T1 后执行 T2
* 先执行 T2 后执行 T1

以先执行 T1 后执行 T2 为例，两次转账步骤如下：

1. 先执行 T1。
   1. 从磁盘中读取账户 A 的金额。
   2. 账户 A 的金额减去转账的金额，为账户 A 的余额。
   3. 存储账户 A 的余额进磁盘里。
   4. 从磁盘中读取账户 B 的金额。
   5. 账户 B 的金额加上转账的金额，为账户 B 的余额。
   6. 存储账户 B 的余额进磁盘里。
2. 后执行 T2。
   1. 从磁盘中读取账户 A 的金额。
   2. 账户 A 的金额减去转账的金额，为账户 A 的余额。
   3. 存储账户 A 的余额进磁盘里。
   4. 从磁盘中读取账户 B 的金额。
   5. 账户 B 的金额加上转账的金额，为账户 B 的余额。
   6. 存储账户 B 的余额进磁盘里。

没毛病不是吗？但这是对现实世界中的两次**状态转换**，明显的，这两次状态转换是相互**隔离**的。

对于数据库来说，两次转账的步骤可能是这样的（假设两次转账的金额都是 5 元，账户 A 的初始金额为 10 元，账户 B 的初始金额为 10 元，两次转账结束后，账户 A 的余额应该是 0 元，账户 B 的余额应该是 20 元）：

1. 从磁盘中读取账户 A 的金额。（T1）
2. 从磁盘中读取账户 A 的金额。（T2）
3. 账户 A 的金额减去转账的金额，为账户 A 的余额。（T1）
4. 存储账户 A 的余额进磁盘里。（T1）
5. 从磁盘中读取账户 B 的金额。（T1）
6. 账户 B 的金额加上转账的金额，为账户 B 的余额。（T1）
7. 存储账户 B 的余额进磁盘里。（T1）
8. 账户 A 的金额减去转账的金额，为账户 A 的余额。（T2）
9. 存储账户 A 的余额进磁盘里。（T2）
10. 从磁盘中读取账户 B 的金额。（T2）
11. 账户 B 的金额加上转账的金额，为账户 B 的余额。（T2）
12. 存储账户 B 的余额进磁盘里。（T2）

最终，账户 A 的余额为 5 元，账户 B 的月为 20 元，这和我们的设想相去甚远。

**注意：这并没有违反原子性。因为原子性只要我们保证 T1 或 T2 的操作步骤，要么全成功，要么全失败就行了，并没有说 T1、T2 的步骤不可互相干扰。**

错误的结果使得我们不得不开始思考，仅仅保证转账操作的原子性，就行了吗？我们应该还要保证两次转账操作的隔离性！也就是 T1、T2 的步骤是不可以相互干扰的！

所以对于现实世界中状态转换对应的某些数据库操作来说，不仅要保证这些操作以原子性的方式执行完成，还要保证其它的状态转换不会影响到本次的状态转换，这个规则被称之为**隔离性**。

<br />

### 一致性（Consistency）

---

#### 一致性的概念

---

数据库世界是现实世界的一个映射，**若数据库中的数据全部符合现实世界中的约束（All Defined Rules），我们就可以说数据库中的数据是一致的，或者说数据库中的数据是符合一致性的。**

何为现实世界的约束？举几个简单的例子：

* 没有小于或等于 0 面值的钞票。
* 2019 年的高考总分范围在 [0 , 750]。

<br />

#### 如何保证数据库中数据的一致性

---

保证数据库中数据的一致性，靠两个方面：

* **数据库自身可以保证一部分现实世界的约束永远有效。**例如：

  * 为表建立主键、唯一索引、外键等。
  * 声明表中某个列为 NOT NULL 来拒绝 NULL 值的插入。
  * 通过定义触发器的方式来自定义一些约束条件以保证数据库中数据的一致性。

  需要注意的是，CHECK 子句在 MySQL 中并无作用，也就是说下面的 SQL 语句，其 CHECK 子句无效。

  ```mysql
  CREATE TABLE account (
      id INT NOT NULL AUTO_INCREMENT COMMENT '自增id',
      name VARCHAR(100) COMMENT '客户名称',
      balance INT COMMENT '余额',
      PRIMARY KEY (id),
      -- CHECK 子句规定 balance 列不能存储小于 0 的数字，但很可惜，MySQL 仅仅支持 CHECK 的语法，而不能让他发挥作用。 也就是说，含有 CHECK 子句的 SQL 可以执行但是其 CHECK 子句的约束无效，在后续对 account 表插入或者更新记录时，MySQL 并不会去检查 CHECK 子句的约束是否成立。
      -- 其它的一些数据库，例如 SQL Server 或者 Oracle 的 CHECK 语法是有实实在在的作用的，每次进行插入或更新记录时，都会检查一下数据是否符合 CHECK 子句中指定的约束条件，如果不符合则会拒绝插入或更新。
      CHECK (balance >= 0) 
  );
  ```

* **更多的一致性需求需要程序员自己保证。**更改数据库数据时进行数据库层面的一致性检查是十分耗费性能的，因此，一致性需求问题的解决，更多的交给了业务端的程序员们。

  举个例子，银行要求每笔交易完成后，都需要保证整个系统的余额等于所有账户的收入减去所有账户的支出。

  我们若使用数据库触发器来完成这个一致性需求，当账单表（里面记录了每个账户的每笔交易）记录数特别庞大时，数据库的性能就会直线下降！这是不可接受的！
  
  这时候就该程序员出马了，对于程序员来说，上述保证一致性需求的操作，可以细分为更小的检查一致性的操作，即在业务代码中对每笔交易做判断，当某个操作会把 balance 列的值更新为小于 0 的值时，不执行该操作即可。

<br />

#### 原子性、隔离性和一致性之间的关系

---

以转账为例，若数据库不遵循原子性要求，那么就可能会发生转一半服务器宕机，导致钱被转出而没被收到的事故，这是不符合一致性需求的。若数据库不遵循隔离性要求，那么就可能发生钱只转了一份，对方却收到两份钱的事故，这也是不符合一致性需求的。

综上所述，**数据库某些操作的原子性和隔离性都是保证一致性的一种手段，在操作执行完成后，保证符合所有既定约束规则的操作是一种结果。**但是，**满足原子性和隔离性不一定满足一致性**，例如余额为 10 元的账户 A，在连续两次转账 10 元给账户 B 后，账户 A 的余额为 -10 元，这显然不符合一致性。**不满足原子性和隔离性可能满足一致性**，只要最后的结果符合现实世界中的约束，那么就是符合一致性的。

<br />

### 持久性（Durability）

---

当现实世界的一个状态转换完成后，这个转换的结果将永久的保留，这个规则即**持久性**。

也就是说，当把现实世界的状态转换映射到数据库世界时，该转换对应的数据库操作所修改的数据应该在磁盘上被保留下来，不论之后发生什么事故，本次转换造成的影响都不应该被丢失掉。

<br />

## 事务的概念

---

### 何为事务

---

需要保证原子性、隔离性、一致性和持久性的一个或多个数据库操作被称为**一个事务（英文名：Transaction）**。

<br />

### 事务的状态

---

事务对应一个或多个数据库操作，这些操作所执行的不同阶段把事务大致上划分成了如下几个状态：

* **活动的（Active）**：事务对应的数据库操作正在执行过程中，即该事务处在**活动的**状态。
* **部分提交的（Partially Committed）**：当事务的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，即该事务处在**部分提交的**状态。
* **失败的（Failed）**：当事务处于 Active 或 Partially Committed 状态时，遇到了某些错误而无法继续执行，或人为的停止了当前事务的执行，即该事务处在**失败的**状态。
* **中止的（Aborted）**：当事务于 Failed 状态回滚，即该事务处在**中止的**状态。
* **提交的（Committed）**：当事务于 Partially Committed 状态将修改过的数据都同步到了磁盘上，即该事务处在**提交的**状态。

上述状态中，**Aborted 状态和 Committed 状态代表了事务生命周期的结束**。对已提交的事务而言，该事务对数据库所做的修改永久生效。对于中止的事务而言，该事务对数据库所做的所有修改都会被回滚到没执行该事务之前的状态。

<br />

### MySQL 事务的语法

---

#### 开启事务

---

有两种方法可以开启事务：

* `BEGIN [WORK];`：BEGIN 语句代表开启一个事务，后边的 WORK 单词可有可无。

  ```mysql
  -- 开启事务 SQL
  BEGIN;
  
  -- 这里是加入事务的 SQL 语句。开启事务后，继续写下的若干条 SQL 语句都属于刚刚开启的事务
  ...
  ```

* `START TRANSACTION;`：START TRANSACTION 语句代表开启一个事务，但 START TRANSACTION 语句后可以跟随相关修饰符，相关修饰符如下。

  * READ ONLY：标识当前事务是一个只读事务。

    **注意：这个只读是针对于其他事务也能访问到的表中的数据而言的，对于临时表而言（使用 CREATE TMEPORARY TABLE 创建的表），由于临时表只在当前会话中可见，所以只读事务也可以对临时表进行增删改操作。**

  * READ WRITE：标识当前事务是一个读写事务。

  * WITH CONSISTENT SNAPSHOT：启动一致性读。
  
  ```mysql
  -- 开启事务，默认事务是读写事务
  START TRANSACTION;
  
  -- 以只读的方式开启事务
  START TRANSACTION READ ONLY;
  
  -- 以只读并且一致性读的方式开启事务
  START TRANSACTION READ ONLY,WITH CONSISTENT SNAPSHOT;
  
  -- 注意，READ ONLY 和 READ WRITE 是用来设置事务访问模式的，所以它们不能同时放在 START TRANSACTION 语句后。
  ```

<br />

#### 提交事务

---

在开启并书写完需要放到事务中的 SQL 语句后，我们可以提交事务。

```mysql
-- 开启事务 SQL
BEGIN;

-- 这里是加入事务的 SQL 语句。开启事务后，继续写下的若干条 SQL 语句都属于刚刚开启的事务
...

-- 提交事务，WORK 单词可有可无
COMMIT [WORK];
```

<br />

#### 手动终止事务

---

在开启并书写需要放到事务中的 SQL 语句时，若发现需要放到事务中的 SQL 语句存在错误的 SQL 语句，我们可以手动回滚，将数据库恢复到事务执行之前的样子。

```mysql
-- 开启事务 SQL
BEGIN;

-- 这里是加入事务的 SQL 语句，其中存在错误的 SQL 语句
-- 开启事务后，继续写下的若干条 SQL 语句都属于刚刚开启的事务
...

-- 回滚事务，WORK 单词可有可无
ROLLBACK [WORK];
```

ROLLBACK 语句是程序员**手动**回滚事务时使用的语句，若事务在执行过程中遇到了错误而无法继续执行，则事务本身会**自动**的回滚。

<br />

### 支持事务的存储引擎

---

**目前只有 InnoDB 和 NDB 存储引擎支持事务功能**。这也就是说，使用不支持事务功能的存储引擎，其所创建的表若在事务中被修改，无法回滚。

<br />

### 自动提交

---

系统变量`autocommit`的值默认为 ON，意思是开启**事务的自动提交**。所谓事务的自动提交，即若不显式的使用`START TRANSACTION`或者`BEGIN`语句开启一个事务，那么每一条 SQL 语句都算是一个独立的事务。

若我们关闭了事务的自动提交，那么在关闭事务的自动提交后接着书写的多条 SQL 语句，在显式的`COMMIT`或`ROLLBACK`之前，都处在同一个事务中。

关闭事务的自动提交有两种方法：

* 使用 SQL 语句`SET autocommit = OFF;`。
* 显式的使用`START TRANSACTION`或者`BEGIN`语句开启一个事务。

**注意：第二种关闭事务自动提交的方法，仅在本次事务提交或者回滚前生效，也就是说只会暂时的关闭掉自动提交的功能。**

<br />

### 隐式提交

---

当我们关闭了事务的自动提交后，输入的某些特殊语句导致了事务被悄悄的提交掉，这种情况便是**隐式提交**。

会导致隐式提交的特殊语句包括：

* 定义或修改数据库对象的数据定义语言（DDL，即 Data Definition Language）。

  数据库对象指的是数据库、表、视图、存储过程等。当我们使用 CREATE、ALTER、DROP 等语句去修改数据库对象时，就会隐式的提交掉前面的 SQL 语句所属于的事务。

* 使用或修改 mysql 数据库中的表。

  当我们使用`ALTER USER`、`CREATE USER`、`DROP USER`、`GRANT`、`RENAME USER`、`REVOKE`、`SET PASSWORD`等语句时也会隐式的提交掉前面的语句所属于的事务。

* 关于事务控制的语句。

  当上一个事务还没有被提交或回滚，我们就开启了下一个事务或将系统变量`autocommit`的值从 OFF 设置为 ON，那么上一个事务会被隐式的提交掉。

* 关于锁定的语句。

  当上一个事务还没有被提交或回滚，我们就使用`LOCK TABLES`、`UNLOCK TABLES`等关于锁定的语句，那么上一个事务会被隐式的提交掉。

* 加载数据的语句。
  
  例如使用`LOAD DATA`语句来批量的往数据库中导入数据，会导致隐式的提交前面语句所属的事务。
  
* 关于 MySQL 复制的一些语句。
  
  使用`START SLAVE`、`STOP SLAVE`、`RESET SLAVE`、`CHANGE MASTER TO`等语句时也会隐式的提交前面语句所属的事务。
  
* 其他的一些语句。
  
  使用`ANALYZE TABLE`、`CACHE INDEX`、`CHECK TABLE`、`FLUSH`、 `LOAD INDEX INTO CACHE`、`OPTIMIZE TABLE`、`REPAIR TABLE`、`RESET`等语句也会隐式的提交前面语句所属的事务。
  

<br />

### 保存点

---

事务提交或回滚之前我们可以设立多个保存点（英文名：savepoint）。

当我们不想因为一个 SQL 语句的出错导致整个事务的回滚，而后需要重新写一遍事务中所有的 SQL 语句时，我们可以通过保存点将数据库回滚到打保存点时的数据库状态。

```mysql
-- 开启事务 SQL
BEGIN;

-- 执行 SQL1（这是一个正确的 SQL 语句）
...

-- 打一个保存点 s1，语法为：SAVEPOINT 保存点名称;
SAVEPOINT s1;

-- 执行 SQL2（这是一个错误的 SQL 语句）
...

-- 回滚到保存点 s1，语法为：ROLLBACK [WORK] TO [SAVEPOINT] 保存点名称;
-- 回滚保存点语法中的单词 WORK 和 SAVEPOINT 都可有可无
-- 注意，若 ROLLBACK 语句后不跟随保存点的名称，则会直接回滚到事务执行之前的状态。
ROLLBACK TO s1;

-- 执行 SQL3（这是一个正确的 SQL 语句）
...

-- 释放（删除）保存点 s1，语法为：RELEASE SAVEPOINT 保存点名称;
RELEASE SAVEPOINT s1;
```



  





















