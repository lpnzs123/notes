# Mysql是怎样运行的：第十九章笔记

---

## ACID

---

对数据库的每一个操作都相当于对操作对应的，现实世界中的对象的一次**状态转换**（例如数据库的一次转账操作使得现实世界中的账户的一次状态转换）。我们想让对数据库的操作符合现实世界中状态转换的规则，就必须先知道状态转换的规则有哪些。标题已经给出了答案，ACID，下面我们来介绍一下**数据库的四大特性（ACID）**。

<br />

### 原子性（Atomicity）

---

原子意味着不可分割。

一个操作可以被分解成若干个步骤，在执行这个操作后，有三种情况：

* 步骤全成功。
* 步骤中有些成功有些失败。
* 步骤全失败。

现在假设这个操作是一次转账，明显的，这个操作有两个基本的步骤（账户 A 转钱给账户 B）：

1. 把钱从账户 A 中取出来。
2. 把从账户 A 中取出来的钱转给账户 B。

问题来了，当步骤 1 完成后系统宕机，导致了步骤 2 没有进行，这时候怎么办呢？

这种情况应该是不允许发生的，我们希望两个步骤先后发生，要么全做，要么全不做，这才是一次转账操作，或者说，这就是**原子性**。也就是说，我们希望转账操作是原子的，是不可分割的，我们不希望转账操作还可以被分成两个步骤分别进行，存在可能一个成功一个失败的**中间态**。

如何处理一个不可分割的操作执行后产生的中间态？当然是将已经执行的操作撤销，将状态恢复到执行不可分割的操作之前的样子。

<br />

### 隔离性（Isolation）

---

仍以一次转账操作为例（账户 A 转钱给账户 B），列出操作的基本步骤如下（步骤做了二次细分，列出了更详细的步骤）：

1. 把钱从账户 A 中取出来。
   1. 从磁盘中读取账户 A 的金额。
   2. 账户 A 的金额减去转账的金额，为账户 A 的余额。
   3. 存储账户 A 的余额进磁盘里。
2. 把从账户 A 中取出来的钱转给账户 B。
   1. 从磁盘中读取账户 B 的金额。
   2. 账户 B 的金额加上转账的金额，为账户 B 的余额。
   3. 存储账户 B 的余额进磁盘里。

这里我们认为转账操作是原子的，不可分割。也就是说，上述步骤要么全做，要么全不做。现在我们**同时**执行两次转账金额相同的转账操作，两次都是账户 A 转钱给账户 B。

假设两次转账操作分别为 T1 和 T2，**理想情况下**，有两种执行方式：

* 先执行 T1 后执行 T2
* 先执行 T2 后执行 T1

以先执行 T1 后执行 T2 为例，两次转账步骤如下：

1. 先执行 T1。
   1. 从磁盘中读取账户 A 的金额。
   2. 账户 A 的金额减去转账的金额，为账户 A 的余额。
   3. 存储账户 A 的余额进磁盘里。
   4. 从磁盘中读取账户 B 的金额。
   5. 账户 B 的金额加上转账的金额，为账户 B 的余额。
   6. 存储账户 B 的余额进磁盘里。
2. 后执行 T2。
   1. 从磁盘中读取账户 A 的金额。
   2. 账户 A 的金额减去转账的金额，为账户 A 的余额。
   3. 存储账户 A 的余额进磁盘里。
   4. 从磁盘中读取账户 B 的金额。
   5. 账户 B 的金额加上转账的金额，为账户 B 的余额。
   6. 存储账户 B 的余额进磁盘里。

没毛病不是吗？但这是对现实世界中的两次**状态转换**，明显的，这两次状态转换是相互**隔离**的。

对于数据库来说，两次转账的步骤可能是这样的（假设两次转账的金额都是 5 元，账户 A 的初始金额为 10 元，账户 B 的初始金额为 10 元，两次转账结束后，账户 A 的余额应该是 0 元，账户 B 的余额应该是 20 元）：

1. 从磁盘中读取账户 A 的金额。（T1）
2. 从磁盘中读取账户 A 的金额。（T2）
3. 账户 A 的金额减去转账的金额，为账户 A 的余额。（T1）
4. 存储账户 A 的余额进磁盘里。（T1）
5. 从磁盘中读取账户 B 的金额。（T1）
6. 账户 B 的金额加上转账的金额，为账户 B 的余额。（T1）
7. 存储账户 B 的余额进磁盘里。（T1）
8. 账户 A 的金额减去转账的金额，为账户 A 的余额。（T2）
9. 存储账户 A 的余额进磁盘里。（T2）
10. 从磁盘中读取账户 B 的金额。（T2）
11. 账户 B 的金额加上转账的金额，为账户 B 的余额。（T2）
12. 存储账户 B 的余额进磁盘里。（T2）

最终，账户 A 的余额为 5 元，账户 B 的月为 20 元，这和我们的设想相去甚远。

**注意：这并没有违反原子性。因为原子性只要我们保证 T1 或 T2 的操作步骤，要么全成功，要么全失败就行了，并没有说 T1、T2 的步骤不可互相干扰。**

错误的结果使得我们不得不开始思考，仅仅保证转账操作的原子性，就行了吗？我们应该还要保证两次转账操作的隔离性！也就是 T1、T2 的步骤是不可以相互干扰的！

所以对于现实世界中状态转换对应的某些数据库操作来说，不仅要保证这些操作以原子性的方式执行完成，还要保证其它的状态转换不会影响到本次的状态转换，这个规则被称之为**隔离性**。

<br />

### 一致性（Consistency）

---

#### 一致性的概念

---

数据库世界是现实世界的一个映射，**若数据库中的数据全部符合现实世界中的约束（All Defined Rules），我们就可以说数据库中的数据是一致的，或者说数据库中的数据是符合一致性的。**

何为现实世界的约束？举几个简单的例子：

* 没有小于或等于 0 面值的钞票。
* 2019 年的高考总分范围在 [0 , 750]。

<br />

#### 如何保证数据库中数据的一致性

---

保证数据库中数据的一致性，靠两个方面：

* **数据库自身可以保证一部分现实世界的约束永远有效。**例如：

  * 为表建立主键、唯一索引、外键等。
  * 声明表中某个列为 NOT NULL 来拒绝 NULL 值的插入。
  * 通过定义触发器的方式来自定义一些约束条件以保证数据库中数据的一致性。

  需要注意的是，CHECK 子句在 MySQL 中并无作用，也就是说下面的 SQL 语句，其 CHECK 子句无效。

  ```mysql
  CREATE TABLE account (
      id INT NOT NULL AUTO_INCREMENT COMMENT '自增id',
      name VARCHAR(100) COMMENT '客户名称',
      balance INT COMMENT '余额',
      PRIMARY KEY (id),
      -- CHECK 子句规定 balance 列不能存储小于 0 的数字，但很可惜，MySQL 仅仅支持 CHECK 的语法，而不能让他发挥作用。 也就是说，含有 CHECK 子句的 SQL 可以执行但是其 CHECK 子句的约束无效，在后续对 account 表插入或者更新记录时，MySQL 并不会去检查 CHECK 子句的约束是否成立。
      -- 其它的一些数据库，例如 SQL Server 或者 Oracle 的 CHECK 语法是有实实在在的作用的，每次进行插入或更新记录时，都会检查一下数据是否符合 CHECK 子句中指定的约束条件，如果不符合则会拒绝插入或更新。
      CHECK (balance >= 0) 
  );
  ```

* **更多的一致性需求需要程序员自己保证。**更改数据库数据时进行数据库层面的一致性检查是十分耗费性能的，因此，一致性需求问题的解决，更多的交给了业务端的程序员们。

  举个例子，银行要求每笔交易完成后，都需要保证整个系统的余额等于所有账户的收入减去所有账户的支出。

  我们若使用数据库触发器来完成这个一致性需求，当账单表（里面记录了每个账户的每笔交易）记录数特别庞大时，数据库的性能就会直线下降！这是不可接受的！
  
  这时候就该程序员出马了，对于程序员来说，上述保证一致性需求的操作，可以细分为更小的检查一致性的操作，即在业务代码中对每笔交易做判断，当某个操作会把 balance 列的值更新为小于 0 的值时，不执行该操作即可。

<br />

#### 原子性、隔离性和一致性之间的关系

---

以转账为例，若数据库不遵循原子性要求，那么就可能会发生转一半服务器宕机，导致钱被转出而没被收到的事故，这是不符合一致性需求的。若数据库不遵循隔离性要求，那么就可能发生钱只转了一份，对方却收到两份钱的事故，这也是不符合一致性需求的。

综上所述，**数据库某些操作的原子性和隔离性都是保证一致性的一种手段，在操作执行完成后，保证符合所有既定约束规则的操作是一种结果。**但是，**满足原子性和隔离性不一定满足一致性**，例如余额为 10 元的账户 A，在连续两次转账 10 元给账户 B 后，账户 A 的余额为 -10 元，这显然不符合一致性。**不满足原子性和隔离性可能满足一致性**，只要最后的结果符合现实世界中的约束，那么就是符合一致性的。

<br />

### 持久性（Durability）

---

当现实世界的一个状态转换完成后，这个转换的结果将永久的保留，这个规则即**持久性**。

也就是说，当把现实世界的状态转换映射到数据库世界时，该转换对应的数据库操作所修改的数据应该在磁盘上被保留下来，不论之后发生什么事故，本次转换造成的影响都不应该被丢失掉。

<br />

## 事务的概念

---



































