# Mysql是怎样运行的：第十五章笔记

---

## 前置准备

---

一条查询语句在经过 MySQL 查询优化器的各种基于成本和规则的优化后，会生成一个所谓的**执行计划**，执行计划展示了接下来具体执行查询的方式。通过 **EXPLAIN** 关键字，我们可以查看某个查询语句的具体执行计划，从而可以针对性的提升我们查询语句的性能。例如：

```mysql
-- 使用 EXPLAIN 关键字查看某个查询语句的具体执行计划
-- 除了 SELECT 语句可以使用 EXPLAIN 关键字，DELETE、INSERT、REPLACE 以及 UPDATE 语句也可以使用 EXPLAIN 关键字来查看这些语句的执行计划
EXPLAIN SELECT 1;
```

该 SQL 会输出一个表（即一个 EXPLAIN 语句的结果集），其中的各个列释义大致如下：

|     列名      |                             描述                             |
| :-----------: | :----------------------------------------------------------: |
|      id       | 在一个大的查询语句中，每个 SELECT 关键字都对应一个唯一的 id  |
|  select_type  |                 SELECT 关键字对应查询的类型                  |
|     table     |                             表名                             |
|  partitions   |                        匹配的分区信息                        |
|     type      |                      针对单表的访问方法                      |
| possible_keys |                        可能用到的索引                        |
|      key      |                        实际使用的索引                        |
|    key_len    |                      实际使用的索引长度                      |
|      ref      |    当使用索引列等值查询时，与索引列进行等值匹配的对象信息    |
|     rows      |                    预估需要读取的记录条数                    |
|   filtered    | 针对预估需要读取的记录，经过搜索条件过滤后剩余记录条数的百分比 |
|     Extra     |                        一些额外的信息                        |

现在存在表 single_table ，结构如下：

```mysql
CREATE TABLE single_table (
    id INT NOT NULL AUTO_INCREMENT,
    key1 VARCHAR(100),
    key2 INT,
    key3 VARCHAR(100),
    key_part1 VARCHAR(100),
    key_part2 VARCHAR(100),
    key_part3 VARCHAR(100),
    common_field VARCHAR(100),
    PRIMARY KEY (id),
    KEY idx_key1 (key1),
    UNIQUE KEY idx_key2 (key2),
    KEY idx_key3 (key3),
    KEY idx_key_part(key_part1, key_part2, key_part3)
) Engine=InnoDB CHARSET=utf8;
```

表 s1 和表 s2 和表 single_table 的结构相同，它们各自有 10000 条记录，除 id 列外其余的列都插入随机值。

<br />

## 执行计划输出中各列详解

---

### table

---

无论多复杂的查询语句，里面包含了多少个表，最后都是要对每个表进行单表访问的。MySQL 规定：**EXPLAIN 语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名**。

<br />

### id

---

什么情况下在一条查询语句中会出现多个 SELECT 关键字？

有两种情况：

* 查询中包含子查询的情况。
* 查询中包含 UNION 语句的情况。

**查询语句中每出现一个 SELECT 关键字，MySQL 就会为它分配一个唯一的 id 值**。而这个 id 值，就是 EXPLAIN 语句结果集的第一个列。

**对于连接查询**，一个 SELECT 关键字，它的 FROM 子句中可以有多个表，每个表都会对应 EXPLAIN 语句结果集中的一条记录。**但是对于这些记录，其 id 列的值都是相同的。并且，按记录出现在结果集中的顺序，出现在前面的表为驱动表，后面的表为被驱动表。**

**对于包含子查询的查询**，每个 SELECT 关键字都会对应一个唯一的 id 值。

但是注意，**查询优化器可能会对涉及子查询的查询语句进行重写，从而将其转换为连接查询**。若我们想知道查询优化器是否对某个包含子查询的语句进行了重写，我们应该怎么做呢？

直接查看执行计划就可以了，结合我们上述所说，若执行计划结果集中，外层查询和子查询对应的记录的 id 列的值都是一样的，则说明查询优化器将子查询转换为了连接查询。

**对于包含 UNION 子句的查询**，每个 SELECT 关键字也都会对应一个唯一的 id 值。但是和包含子查询的查询还是有区别的，例如：

```mysql
-- EXPLAIN 语句
EXPLAIN SELECT * FROM s1  UNION SELECT * FROM s2;

-- EXPLAIN 语句结果集
+----+-------------+----------+------------+------+---------------+-----+---------+-----+------+----------+-----------------+
| id | select_type | table    | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra           |
+----+-------------+----------+------------+------+---------------+-----+---------+-----+------+----------+-----------------+
| 1  | PRIMARY     | s1       | NULL       | ALL  | NULL          |NULL | NULL    |NULL | 9688 |   100.00 | NULL            |
+----+-------------+----------+------------+------+---------------+-----+---------+-----+------+----------+-----------------+
| 2  | UNION       | s2       | NULL       | ALL  | NULL          |NULL | NULL    |NULL | 9954 |   100.00 | NULL            |
+----+-------------+----------+------------+------+---------------+-----+---------+-----+------+----------+-----------------+
|NULL|UNION RESULT |<union1,2>| NULL       | ALL  | NULL          |NULL | NULL    |NULL | NULL |     NULL | Using temporary |
+----+-------------+----------+------------+------+---------------+-----+---------+-----+------+----------+-----------------+
```

EXPLAIN 语句结果集中第三条记录 id 值为 NULL ，这是因为 UNION 关键字会将多个查询的结果集合并起来做去重的操作，而去重操作用到了临时表，这个临时表就是 EXPLAIN 语句结果集的第三条记录的由来。

通过 EXPLAIN 语句结果集我们可知，MySQL 在内部创建了一个名为`<union1, 2>`的临时表（就是执行计划第三条记录的 table 列名称），对应EXPLAIN 语句结果集中的第三条记录。记录的 id 列的值为 NULL 表示这个临时表是为了合并两个查询的结果集而创建的。

那不进行合并结果集后的去重，是否就没有 EXPLAIN 语句结果集中的第三条记录了呢？是的，不要去重，也就是不需要临时表，我们可以使用 UNION ALL 关键字（UNION ALL 只是单纯把多个查询结果集中的记录合并成一个返回给用户）来达成这一效果，最终在包含 UNION ALL 子句查询的执行计划中，没有上述 id 列为 NULL 的记录。

<br />

### select_type

---











<br />

### partitions

---





















